## Project: biosigner
## Details: Helper functions to evaluate the significance of the features
##          by using the models generated by bootstrap
##          and to iterate the process to compute the tiers
## Authors: Philippe Rinaudo and Etienne Thevenot (CEA)


## SPECIFICATIONS: For a given method (PLS-DA, Random Forest, and SVM)
##                 at a given iteration step (i.e. tier; dataset restricted to
##                                            a selected number of features)
##                 computes the bootstrap models, the aggregated accuracy
##                 and the variable significance
## INPUT: dataLs: data and metadata
##        respC (character): a response name, i.e. name of a column of the
##                           observations of dataLs
##        permI (integer): number permutations
## OUTPUT: list with the FSI, the mean rank (used for stepwise) and the significance of each variable, and the accuracy of the model
getBootSignificanceF <- function(dataLs = NULL,
                                 respC = NULL,
                                 methC = NULL,
                                 bootI = 50,
                                 permI = 1,
                                 pvalN = 0.05,
                                 fixRankL = FALSE,
                                 fullModelL = FALSE){

    switch(methC,
           "plsda" = {
               methC = "opls"
               methArgLs = list(permI = 0, printL = FALSE, plotL = FALSE)
               methNamLs = list(x="x", y="y")
               predNamLs = list(object="object", newdata="newdata")
               predArgLs= NULL
           },
           "randomforest" = {
               methC = "randomForest"
               methArgLs = list(importance=TRUE,localImp=TRUE, proximity=TRUE)
               methNamLs = list(x="x", y="y")
               predNamLs = list(object="object", newdata="newdata")
               predArgLs = NULL
               ## removing all variables with NA
               ind <- unique(which(is.na(dataLs$dataMatrix), arr.ind = TRUE)[, "col"])
               if(length(ind)) {
                   varNamVc <- colnames(dataLs$dataMatrix)[ind]
                   warning("The following variables(s) contain(s) 'NA' values and will be removed from the RandomForest models: '",
                           paste(varNamVc, collapse = "', '"),
                           "'")
                   dataLs$dataMatrix <- dataLs$dataMatrix[,-ind,drop=FALSE]
                   dataLs$variableMetadata <- dataLs$variableMetadata[-ind,,drop=FALSE]
               }
           },
           "svm" = {
               methC = "svm"
               methArgLs = list(kernel="linear", cost=1)
               ## methArgLs = list(kernel="linear", cost=10)
               ## methArgLs = list(kernel="radial", cost=10)
               methNamLs = list(x="x", y="y")
               predNamLs = list(object="object", newdata="newdata")
               predArgLs = list(probability = FALSE)
               ## removing all variables with NA
               ind <- unique(which(is.na(dataLs$dataMatrix), arr.ind = TRUE)[, "col"])
               if(length(ind)) {
                   varNamVc <- colnames(dataLs$dataMatrix)[ind]
                   warning("The following variables(s) contain(s) 'NA' values and will be removed from the SVM models: '",
                           paste(varNamVc, collapse = "', '"),
                           "'")
                   dataLs$dataMatrix <- dataLs$dataMatrix[,-ind,drop=FALSE]
                   dataLs$variableMetadata <- dataLs$variableMetadata[-ind,,drop=FALSE]
               }
           },
           stop(paste0("Undefined method, must be in ('svm', 'plsda', 'randomforest'), but attempt to use ", methC))
           )

    bootModelLs <- getBootModelF(dataLs = dataLs,
                                 respC = respC,
                                 methC = methC,
                                 methNamLs = methNamLs,
                                 methArgLs = methArgLs,
                                 predNamLs = predNamLs,
                                 predArgLs = predArgLs,
                                 bootI = bootI,
                                 fixRankL = fixRankL)

    if(permI > 0){

        signifVn <- getSignificanceF(bootModelLs = bootModelLs,
                                     dataLs = bootModelLs$dataLs,
                                     respC = respC,
                                     predNamLs = predNamLs,
                                     predArgLs = predArgLs,
                                     permI = permI,
                                     pvalN = pvalN)

        bootModelLs$signifVn <- signifVn

    }

    if(fullModelL){
        full.model <- getModelF(dataLs$dataMatrix,
                                dataLs$sampleMetadata[, respC],
                                methC = methC,
                                methNamLs = methNamLs,
                                methArgLs = methArgLs)
        bootModelLs$model <- full.model
    }

    return(bootModelLs)

} ## getBootSignificanceF


## Looks for the significant feature closest to pvalN by dichotomy
## returns a numeric vector indicating for each variable if it is relevant (0) or not (-1)
getSignificanceF <- function(bootModelLs = NULL,
                             dataLs = NULL,
                             respC = NULL,
                             predNamLs = list(object = "object",
                                 newdata = "newdata"),
                             predArgLs = NULL,
                             permI = 0,
                             pvalN = 0.05){

    bootI <- length(bootModelLs$modelAccuRankLs)

    rankOrdVi <- order(bootModelLs$rankVn)

    boundMinI <- 1
    boundMaxI <- length(rankOrdVi)

    ## stopL <- FALSE

    i <- boundMinI

    boundMinSignifN <- 1

    while((boundMinI < boundMaxI) |
          (boundMinI == boundMaxI & length(rankOrdVi) == 1)){

        accuracyVn <- rep(0, permI * bootI)

        ## generate the permutated data permI times
        highRankVi <- which(bootModelLs$rankVn >= bootModelLs$rankVn[rankOrdVi[i]])

        for(bI in 1:bootI){ ## number of bootstraps

            for(pI in 1:permI){ ## number of permutations
                ## permute variables

                xTrainPermMN <- dataLs$dataMatrix
                xTrainPermMN[, highRankVi] <- apply(dataLs$dataMatrix[, highRankVi, drop=FALSE], 2, sample)

                ## generate prediction model
                ## get test profile
                if(length(bootModelLs$modelAccuRankLs[[bI]]$varCstVi) > 0){
                    xTestPermMN <- xTrainPermMN[bootModelLs$modelAccuRankLs[[bI]]$ind.test,
                                                -bootModelLs$modelAccuRankLs[[bI]]$varCstVi, drop = FALSE]
                } else
                    xTestPermMN <- xTrainPermMN[bootModelLs$modelAccuRankLs[[bI]]$ind.test, , drop=FALSE]

                ## predict
                predTestPermFc <- getPredictionF(bootModelLs$modelAccuRankLs[[bI]]$model,
                                                 xTestPermMN,
                                                 predNamLs = predNamLs,
                                                 predArgLs = predArgLs)
                ## generate evaluation
                yTestFc <- dataLs$sampleMetadata[, respC][bootModelLs$modelAccuRankLs[[bI]]$ind.test]
                accuracyVn[(pI - 1) * bootI + bI] <- bootModelLs$modelAccuRankLs[[bI]]$accuracyN - getAccuracyF(predTestPermFc,
                                                                                                                yTestFc = yTestFc)
                ## negative if the model prediction on the randomized test subset
                ## performs better than on the true test subset
            }
        }

        signifN <- sum(accuracyVn <= 0, na.rm = TRUE) / (bootI * permI)
        if(signifN <= pvalN){
            ## i.e. predictions on the randomized test subset rarely outperforms the true test subset
            ## i.e. some of the permutated features are relevant
            ## i.e. the searched interval is shifted to the features of highest ranks
            boundMinI <- i
            boundMinSignifN <- signifN
        }
        else
            boundMaxI <- i - 1

        if(length(rankOrdVi) == 1)
            boundMaxI <- boundMinI - 1

        i <- ceiling((boundMinI + boundMaxI) / 2)

    }

    signifVn <- rep(-1, length(bootModelLs$rankVn))
    names(signifVn) <- rownames(dataLs$variableMetadata)

    if(boundMinSignifN <= pvalN)
        signifVn[rankOrdVi[1:boundMinI]] <- 0

    return(signifVn)

} ## getSignificanceF


getTierF <- function(datasetLs,
                     methodC,
                     bootI,
                     permI,
                     pvalN,
                     fixRankL) {

    fsiResLs <- list()

    tierVn <- numeric(ncol(datasetLs[["dataMatrix"]]))
    names(tierVn) <- colnames(datasetLs[["dataMatrix"]])

    stopIterL <- FALSE

    fsiResLs <- getBootSignificanceF(datasetLs,
                                     "respC",
                                     methodC,
                                     bootI = bootI,
                                     permI = permI,
                                     pvalN = pvalN,
                                     fixRankL = fixRankL)
    ## Begin iteration step
    ## extract significant variable in the last recursive step
    varSelVc <- names(which(fsiResLs$signifVn <= pvalN &
                            fsiResLs$signifVn >= 0))
    if(length(varSelVc) < 1){
        varSelVc <- fsiResLs$varNamVc[which(fsiResLs$rankVn %in% 1:(nrow(datasetLs$variableMetadata)/2))]
        varSelVi <- which(rownames(datasetLs$variableMetadata) %in% varSelVc)
        tierVn[varSelVi] <- tierVn[varSelVi] - 1
    }
    stopIterL <- FALSE
    nb.rec <- 0
    ## fsi.rec <- rep(-1, nrow(datasetLs$variableMetadata))
    ## Next line is not actually used
    ## permI.rec <- permI * ceiling(nrow(datasetLs$variableMetadata) / length(varSelVc))
    while(length(varSelVc) >= 1 && stopIterL == FALSE){
        ## while the significant variables of the current step is not the same as the ones of the previous step (stop.rec)
        ## extract the data with only the significant variable of the previous step
        datasetLs.rec <- datasetLs
        varSelVi <- which(rownames(datasetLs$variableMetadata) %in% varSelVc)
        ## increase the tiers of the previous significant variables
        tierVn[varSelVi] <- tierVn[varSelVi] + 1
        ## extraction
        datasetLs.rec$dataMatrix <- datasetLs.rec$dataMatrix[, varSelVi, drop = FALSE]
        datasetLs.rec$variableMetadata <- datasetLs.rec$variableMetadata[varSelVi, , drop = FALSE]
        ## computing the fsi for current step
        fsi.rec <- getBootSignificanceF(datasetLs.rec,
                                        "respC",
                                        methodC,
                                        bootI = bootI,
                                        permI = permI,
                                        pvalN = pvalN,
                                        fixRankL = fixRankL)
        ## checking if the number of significant variables has changed, else stop the rec
        if(length(varSelVc) != length(names(which(fsi.rec$signifVn <= pvalN &
                     fsi.rec$signifVn >= 0))) ){
            ## check if we need to iterate on the best half part (ie no significant variable found).
            if(length(varSelVc) > 1 & length(names(which(fsi.rec$signifVn <= pvalN & fsi.rec$signifVn >= 0))) < 1 ){
                varSelVc <- fsi.rec$varNamVc[which(fsi.rec$rankVn %in% 1:(nrow(datasetLs.rec$variableMetadata)/2))]
                varSelVi <- which(rownames(datasetLs$variableMetadata) %in% varSelVc)
                tierVn[varSelVi] <- tierVn[varSelVi] - 1
            }
            else{
                varSelVc <- names(which(fsi.rec$signifVn <= pvalN & fsi.rec$signifVn >= 0))
            }
            ## permI.rec <- permI.rec * ceiling(nrow(datasetLs.rec$variableMetadata) / length(varSelVc))
        }
        else{
            stopIterL <- TRUE
        }
    }
    ## update the fsiResLs TODO: ACTUALLY NOT USED ANYMORE !! CHECK IT
    varSelVi <- which(rownames(datasetLs$variableMetadata) %in% varSelVc)
    fsiResLs$signifVn[varSelVi] <- fsi.rec$signifVn
    fsiResLs$signifVn[-varSelVi] <- -1

    return(list(tierVn = tierVn,
                accuracyN = fsiResLs$accuracyN,
                stopIterL = stopIterL))

} ## getTierF


